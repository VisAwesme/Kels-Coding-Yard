<#
.CREDITS (and the usual stupid humor...)
If you reuse or remake this script, credit DrKel or visawesme. And if you steal it and claim it as yours, expect a DMCA notice (or at least some serious side-eye).
Horrible code written by Dr. Kel, who loves VoTV so much they started pretending to be Kel (NOT THE KEL FROM OMORI, THE ONE FROM VOICES OF THE VOID).
-- Yeah, I’m not okay.
This script is not responsible for any damage to your system, your sanity, or your cat’s trust in you.
If you experience issues, please contact your local IT department, or better yet, a therapist.
Seriously, don’t run this on your main machine unless you’re ready for the game "Will it boot tomorrow?"
-[--]---[--]---ACTUAL CODE BEGINS HERE---[--]---[--]-
.DANGER
Very dangerous script (who would've guessed?)—this could potentially cause more damage than MEMZ itself.
If you're running this in VMware or VirtualBox, please remember VM escapes are a thing.
.Use Triage if you have a lifetime to spare, but don’t be surprised if it takes 8 hours for your account to get approved.
.SUPERDUPERIMPORTANT
This script is intended for highly controlled environments (e.g., a triage VM or a random computer found under a table).
It forcefully terminates processes and attempts to remove persistence mechanisms associated with MEMZ.exe and its variants.
.IMPORTANT
Before running, make sure to set the execution policy:
  Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
(Side note: don’t blame me if this turns your computer into a toaster.)
.SYNOPSIS
Terminates all processes matching MEMZ variants and removes common persistence mechanisms.
.DESCRIPTION
This script hunts for processes with names like MEMZ.exe, memez.exe, etc. It then uses background jobs to kill them.
It also looks for suspicious scheduled tasks and registry Run entries to help eliminate persistence.
.NOTES
Run this script as Administrator.
WARNING: This script is like a wrecking ball—you might lose some files you didn't know you loved.
#>

# Define primary process name variants (wildcards used for matching)
$processNames = @(
    "memz.exe",       # Standard process name
    "memez.exe",      # Common typo
    "MEMZ*.exe",      # Variations (case-insensitive)
    "memz*.exe",      # Variations
    "memez*.exe",     # Variations
    "MEMEZ*.exe",     # Extra variation
    "memz.exe*",      # Processes starting with memz.exe
    "memez.exe*",     # Processes starting with memez.exe
    "memz.exe 32*"    # Variations including "32" (e.g., 32-bit)
)

# Define additional variants to target using wildcards
$additionalProcessNames = @(
    "memz*.com", "memez*.com",
    "memz*.bat", "memez*.bat",
    "memz*.cmd", "memez*.cmd",
    "memz*.scr", "memez*.scr",
    "memz*.pif", "memez*.pif",
    "memz*.dll", "memez*.dll",
    "memz*.sys", "memez*.sys",
    "memz*.vbs", "memez*.vbs",
    "memz*.js",  "memez*.js",
    "memz*.jse", "memez*.jse",
    "memz*.wsf", "memez*.wsf",
    "memz*.wsh", "memez*.wsh",
    "memz*.ps1", "memez*.ps1",
    "memz*.psm1", "memez*.psm1",
    "memz*.psd1", "memez*.psd1",
    "memz*.hta", "memez*.hta"
)

# Combine the primary and additional process name variants
$processNames += $additionalProcessNames

# Ensure the script is running as Administrator
if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(
    [Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Error "This script must be run as Administrator. Please run it using 'Run as Administrator'."
    exit 1
}

# Array to hold background jobs for killing processes
$jobs = @()

Write-Host "Searching for malicious processes..." -ForegroundColor Cyan

foreach ($name in $processNames) {
    try {
        $procs = Get-Process -Name $name -ErrorAction SilentlyContinue
    } catch {
        $procs = $null
    }
    if ($procs) {
        foreach ($proc in $procs) {
            Write-Host "Scheduling kill for $($proc.Name) (PID: $($proc.Id))" -ForegroundColor Yellow
            $job = Start-Job -ScriptBlock {
                param($pid)
                try {
                    # Attempt to kill any child processes first
                    $childProcs = Get-CimInstance Win32_Process -Filter "ParentProcessId=$pid" -ErrorAction SilentlyContinue
                    foreach ($child in $childProcs) {
                        Stop-Process -Id $child.ProcessId -Force -ErrorAction Stop
                        Write-Output "Killed child process with PID $($child.ProcessId)"
                    }
                    # Kill the parent process
                    Stop-Process -Id $pid -Force -ErrorAction Stop
                    Write-Output "Killed process with PID $pid"
                } catch {
                    Write-Output "Failed to kill process with PID $pid: $_"
                }
            } -ArgumentList $proc.Id
            $jobs += $job
        }
    }
    else {
        Write-Host "No processes found matching: $name" -ForegroundColor Green
    }
}

# Wait for all jobs to complete
if ($jobs.Count -gt 0) {
    Write-Host "Waiting for all kill jobs to finish..." -ForegroundColor Cyan
    Wait-Job -Job $jobs
    foreach ($job in $jobs) {
        Receive-Job -Job $job
    }
    # Verify if any matching process is still running
    $remaining = @()
    foreach ($name in $processNames) {
        $remaining += Get-Process -Name $name -ErrorAction SilentlyContinue
    }
    if ($remaining.Count -eq 0) {
        Write-Host "All instances of memz-related processes have been terminated." -ForegroundColor Green
    } else {
        Write-Warning "Some instances may still be running!"
    }
} else {
    Write-Host "No malicious processes were found to terminate." -ForegroundColor Green
}

# Define common file paths for memz.exe/memez.exe.
$paths = @(
    "$env:USERPROFILE\Downloads\memz.exe",
    "$env:USERPROFILE\Downloads\memez.exe",
    "$env:USERPROFILE\Desktop\memz.exe",
    "$env:USERPROFILE\Desktop\memez.exe",
    "C:\Windows\System32\memz.exe",   # Exact file name; wildcards removed
    "C:\Windows\System32\memez.exe"    # Exact file name; wildcards removed
)

foreach ($path in $paths) {
    if (Test-Path $path) {
        try {
            Remove-Item -Path $path -Force
            Write-Host "Deleted file: $path" -ForegroundColor Green
        } catch {
            Write-Warning "Failed to delete file: $path"
        }
    }
}

# ----- Additional Persistence Removal -----
Write-Host "Checking for persistence mechanisms..." -ForegroundColor Cyan

# Remove Scheduled Tasks related to memz
try {
    $tasks = Get-ScheduledTask | Where-Object { $_.TaskName -like "*memz*" -or $_.TaskName -like "*memez*" }
    if ($tasks) {
        foreach ($task in $tasks) {
            Write-Host "Removing scheduled task: $($task.TaskName)" -ForegroundColor Yellow
            try {
                Unregister-ScheduledTask -TaskName $task.TaskName -Confirm:$false -ErrorAction Stop
                Write-Host "Scheduled task $($task.TaskName) removed." -ForegroundColor Green
            } catch {
                Write-Warning "Failed to remove scheduled task: $($task.TaskName): $_"
            }
        }
    } else {
        Write-Host "No scheduled tasks found for memz variants." -ForegroundColor Green
    }
} catch {
    Write-Warning "Error retrieving scheduled tasks: $_"
}

# Remove Registry Run entries for memz (in HKCU and HKLM)
$registryPaths = @(
    "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
    "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
)
foreach ($regPath in $registryPaths) {
    try {
        $props = Get-ItemProperty -Path $regPath -ErrorAction SilentlyContinue
        if ($props) {
            $propNames = ($props | Get-Member -MemberType NoteProperty).Name
            foreach ($entry in $propNames) {
                if ($entry -match "(?i)memz|memez") {
                    Write-Host "Removing registry entry '$entry' from $regPath" -ForegroundColor Yellow
                    try {
                        Remove-ItemProperty -Path $regPath -Name $entry -ErrorAction Stop
                        Write-Host "Registry entry '$entry' removed." -ForegroundColor Green
                    } catch {
                        Write-Warning "Failed to remove registry entry '$entry': $_"
                    }
                }
            }
        } else {
            Write-Host "No registry entries found in $regPath for memz variants." -ForegroundColor Green
        }
    } catch {
        Write-Warning "Error accessing registry path $regPath: $_"
    }
}

# (Optional) List Volume Shadow Copies – Warning: This may lead to data loss if removed.
try {
    $shadowCopies = vssadmin list shadows
    if ($shadowCopies) {
        Write-Host "Shadow copies detected. Review them manually." -ForegroundColor Yellow
        # To delete all shadow copies, uncomment the next line (WARNING: Data loss potential):
        # vssadmin delete shadows /all /quiet
    } else {
        Write-Host "No shadow copies found." -ForegroundColor Green
    }
} catch {
    Write-Warning "Failed to list shadow copies: $_"
}

Write-Host "Script execution completed." -ForegroundColor Cyan

<#
Hopefully, this enhanced script addresses not just process termination and file deletion but also removes some common persistence mechanisms such as scheduled tasks and registry Run entries.
If you encounter any issues or have additional IoCs to cover, tweak accordingly.
End of script
#>
